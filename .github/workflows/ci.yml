name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Manual trigger
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - destroy

permissions:
  contents: read
  security-events: write  # Required for uploading Trivy SARIF results

env:
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: 1.10.3  # Required for native S3 state locking (use_lockfile)
  KUBECTL_VERSION: 1.31.0  # Matches EKS cluster version (1.31 - stable supported)

jobs:
  # Job 1: Validate and Test
  validate:
    name: Validate Code
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'  # Cache pip dependencies

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt
          pip install flake8 black

      - name: Lint with flake8
        run: |
          flake8 backend/src --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 backend/src --count --max-complexity=10 --max-line-length=120 --statistics

      - name: Check code formatting with black
        run: black --check backend/src

      - name: Validate Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false  # Faster execution

      - name: Terraform Format Check
        working-directory: infrastructure/terraform-eks
        run: terraform fmt -check -recursive

      - name: Cache Terraform plugins
        uses: actions/cache@v3
        with:
          path: infrastructure/terraform-eks/.terraform
          key: ${{ runner.os }}-terraform-${{ hashFiles('infrastructure/terraform-eks/.terraform.lock.hcl') }}
          restore-keys: |
            ${{ runner.os }}-terraform-

      - name: Terraform Init
        working-directory: infrastructure/terraform-eks
        run: terraform init -backend=false

      - name: Terraform Validate
        working-directory: infrastructure/terraform-eks
        run: terraform validate

  # Job 2: Build and Push Backend Image
  build-backend:
    name: Build Backend Image
    runs-on: ubuntu-latest
    needs: [validate, deploy-infra]  # Wait for Terraform to create ECR
    if: github.event.inputs.action != 'destroy'
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract metadata for Backend Docker
        id: meta
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_TAG="${TIMESTAMP}-${SHORT_SHA}"
          echo "tags=${{ steps.login-ecr.outputs.registry }}/fictions-api-development:${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "latest=${{ steps.login-ecr.outputs.registry }}/fictions-api-development:latest" >> $GITHUB_OUTPUT

      - name: Build Backend Docker image
        run: |
          docker build -t ${{ steps.meta.outputs.tags }} ./backend
          docker tag ${{ steps.meta.outputs.tags }} ${{ steps.meta.outputs.latest }}

      - name: Run Trivy vulnerability scanner on Backend
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.meta.outputs.tags }}
          format: 'sarif'
          output: 'trivy-backend-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Backend Trivy scan results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-backend-results.sarif'

      - name: Run Trivy vulnerability scanner on Backend (Table format)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.meta.outputs.tags }}
          format: 'table'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'  # Don't fail the build, just report

      - name: Push Backend Docker image
        run: |
          docker push ${{ steps.meta.outputs.tags }}
          docker push ${{ steps.meta.outputs.latest }}

      - name: Backend image digest
        run: echo "Backend image pushed with tag ${{ steps.meta.outputs.tags }}"

  # Job 3: Build and Push Frontend Image
  build-frontend:
    name: Build Frontend Image
    runs-on: ubuntu-latest
    needs: [validate, deploy-infra]  # Wait for Terraform to create ECR
    if: github.event.inputs.action != 'destroy'
    
    outputs:
      image-tag: ${{ steps.meta.frontend.outputs.tags }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract metadata for Frontend Docker
        id: meta-frontend
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_TAG="${TIMESTAMP}-${SHORT_SHA}"
          echo "tags=${{ steps.login-ecr.outputs.registry }}/fictions-api-frontend-development:${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "latest=${{ steps.login-ecr.outputs.registry }}/fictions-api-frontend-development:latest" >> $GITHUB_OUTPUT

      - name: Build Frontend Docker image
        run: |
          docker build -t ${{ steps.meta-frontend.outputs.tags }} ./frontend
          docker tag ${{ steps.meta-frontend.outputs.tags }} ${{ steps.meta-frontend.outputs.latest }}

      - name: Run Trivy vulnerability scanner on Frontend
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.meta-frontend.outputs.tags }}
          format: 'table'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'

      - name: Push Frontend Docker image
        run: |
          docker push ${{ steps.meta-frontend.outputs.tags }}
          docker push ${{ steps.meta-frontend.outputs.latest }}

      - name: Frontend image digest
        run: echo "Frontend image pushed with tag ${{ steps.meta-frontend.outputs.tags }}"

  # Job 4: Deploy Infrastructure with Terraform
  deploy-infra:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: validate
    if: github.event.inputs.action != 'destroy'
    
    outputs:
      cluster-name: ${{ steps.terraform-output.outputs.cluster_name }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Setup Terraform Backend (S3 with Native Locking)
        run: |
          # Check if S3 bucket exists
          echo "Checking if S3 bucket exists..."
          if aws s3api head-bucket --bucket fictions-api-terraform-state-development --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "âœ… S3 bucket already exists"
          else
            echo "Creating S3 bucket for Terraform state..."
            aws s3api create-bucket \
              --bucket fictions-api-terraform-state-development \
              --region ${{ env.AWS_REGION }}
            
            echo "Enabling S3 bucket versioning..."
            aws s3api put-bucket-versioning \
              --bucket fictions-api-terraform-state-development \
              --versioning-configuration Status=Enabled
            
            echo "Enabling S3 bucket encryption..."
            aws s3api put-bucket-encryption \
              --bucket fictions-api-terraform-state-development \
              --server-side-encryption-configuration '{
                "Rules": [{
                  "ApplyServerSideEncryptionByDefault": {
                    "SSEAlgorithm": "AES256"
                  },
                  "BucketKeyEnabled": true
                }]
              }'
            
            echo "âœ… S3 bucket created successfully"
          fi
          
          echo "âœ… Terraform backend is ready!"
          echo "ðŸ”’ Native S3 state locking enabled (Terraform 1.10+)"
          echo "ðŸ“ Lock files will be stored as .tflock alongside state file"

      - name: Terraform Init
        working-directory: infrastructure/terraform-eks
        run: terraform init

      - name: Terraform Plan
        working-directory: infrastructure/terraform-eks
        run: |
          terraform plan \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -out=tfplan

      - name: Terraform Apply
        working-directory: infrastructure/terraform-eks
        run: terraform apply -auto-approve tfplan

      - name: Get Terraform Outputs
        id: terraform-output
        working-directory: infrastructure/terraform-eks
        run: |
          CLUSTER_NAME=$(terraform output -raw cluster_name)
          echo "cluster_name=${CLUSTER_NAME}" >> $GITHUB_OUTPUT
          terraform output > outputs.txt

      - name: Upload Terraform Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: infrastructure/terraform-eks/outputs.txt

  # Job 5: Deploy to Kubernetes
  deploy-k8s:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend, deploy-infra]
    if: github.event.inputs.action != 'destroy'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v${{ env.KUBECTL_VERSION }}'

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ needs.deploy-infra.outputs.cluster-name }}

      - name: Verify cluster connection
        run: kubectl get nodes

      - name: Get Backend ECR URL
        id: backend-ecr
        run: |
          BACKEND_ECR=$(aws ecr describe-repositories \
            --repository-names fictions-api-development \
            --region ${{ env.AWS_REGION }} \
            --query 'repositories[0].repositoryUri' \
            --output text)
          echo "backend_ecr=${BACKEND_ECR}" >> $GITHUB_OUTPUT

      - name: Get Frontend ECR URL
        id: frontend-ecr
        run: |
          FRONTEND_ECR=$(aws ecr describe-repositories \
            --repository-names fictions-api-frontend-development \
            --region ${{ env.AWS_REGION }} \
            --query 'repositories[0].repositoryUri' \
            --output text)
          echo "frontend_ecr=${FRONTEND_ECR}" >> $GITHUB_OUTPUT

      - name: Update Backend deployment with image
        run: |
          sed -i "s|image:.*|image: ${{ steps.backend-ecr.outputs.backend_ecr }}:latest|g" kubernetes/backend-deployment.yaml

      - name: Update Frontend deployment with image
        run: |
          sed -i "s|image:.*|image: ${{ steps.frontend-ecr.outputs.frontend_ecr }}:latest|g" kubernetes/frontend-deployment.yaml

      - name: Deploy to Kubernetes
        run: |
          kubectl apply -f kubernetes/namespace.yaml
          kubectl apply -f kubernetes/configmap.yaml
          kubectl apply -f kubernetes/secrets.yaml
          kubectl apply -f kubernetes/mongodb.yaml
          kubectl apply -f kubernetes/backend-deployment.yaml
          kubectl apply -f kubernetes/backend-service.yaml
          kubectl apply -f kubernetes/frontend-deployment.yaml
          kubectl apply -f kubernetes/frontend-service.yaml
          kubectl apply -f kubernetes/ingress.yaml
          kubectl apply -f kubernetes/hpa.yaml

      - name: Wait for deployments
        run: |
          kubectl rollout status deployment/fictions-api -n fictions-app --timeout=300s
          kubectl rollout status deployment/fictions-frontend -n fictions-app --timeout=300s
          kubectl rollout status statefulset/mongodb -n fictions-app --timeout=300s

      - name: Get ALB URL from Ingress
        id: get-url
        run: |
          echo "Waiting for ALB to be provisioned..."
          sleep 90
          ALB_URL=$(kubectl get ingress fictions-app-ingress -n fictions-app \
            -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "app_url=http://${ALB_URL}" >> $GITHUB_OUTPUT
          echo "### ðŸš€ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend UI:** http://${ALB_URL}" >> $GITHUB_STEP_SUMMARY
          echo "**Backend API:** http://${ALB_URL}/api" >> $GITHUB_STEP_SUMMARY
          echo "**Swagger UI:** http://${ALB_URL}/api/docs" >> $GITHUB_STEP_SUMMARY

      - name: Check application health
        run: |
          echo "Verifying all pods are running..."
          sleep 30
          kubectl get pods -n fictions-app
          kubectl get ingress -n fictions-app
          
      - name: Display deployment info
        run: |
          echo "==================================================="
          echo "ðŸŽ‰ Full-Stack Deployment Complete!"
          echo "==================================================="
          echo "Frontend:   ${{ steps.get-url.outputs.app_url }}"
          echo "Backend:    ${{ steps.get-url.outputs.app_url }}/api"
          echo "Swagger UI: ${{ steps.get-url.outputs.app_url }}/api/docs"
          echo "==================================================="

  # Job 6: Manual Approval for Destroy
  approval:
    name: Approve Destruction
    runs-on: ubuntu-latest
    if: github.event.inputs.action == 'destroy'
    environment:
      name: production-destroy
    
    steps:
      - name: Wait for approval
        run: |
          echo "âš ï¸  Waiting for manual approval to destroy infrastructure..."
          echo "This will delete ALL resources including:"
          echo "  - EKS Cluster"
          echo "  - VPC and all networking"
          echo "  - Load Balancers"
          echo "  - ECR repositories"
          echo "  - All data will be LOST"

  # Job 7: Destroy Kubernetes Resources
  destroy-k8s:
    name: Destroy Kubernetes Resources
    runs-on: ubuntu-latest
    needs: approval
    if: github.event.inputs.action == 'destroy'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform (to get cluster name)
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Get cluster name
        id: cluster-info
        working-directory: infrastructure/terraform-eks
        run: |
          terraform init
          CLUSTER_NAME=$(terraform output -raw cluster_name || echo "fictions-api-development")
          echo "cluster_name=${CLUSTER_NAME}" >> $GITHUB_OUTPUT

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v${{ env.KUBECTL_VERSION }}'

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ steps.cluster-info.outputs.cluster_name }} || true

      - name: Delete Kubernetes resources
        run: |
          kubectl delete -f kubernetes/ --ignore-not-found=true || true
          kubectl delete namespace fictions-app --ignore-not-found=true || true

      - name: Wait for resources to be deleted
        run: |
          echo "Waiting for LoadBalancer to be deleted..."
          sleep 60

  # Job 8: Destroy Infrastructure
  destroy-infra:
    name: Destroy Infrastructure
    runs-on: ubuntu-latest
    needs: destroy-k8s
    if: github.event.inputs.action == 'destroy'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Init
        working-directory: infrastructure/terraform-eks
        run: terraform init

      - name: Terraform Destroy
        working-directory: infrastructure/terraform-eks
        run: |
          terraform destroy \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -auto-approve

      - name: Cleanup summary
        run: |
          echo "### ðŸ—‘ï¸ Infrastructure Destroyed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All AWS resources have been deleted:" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Kubernetes resources deleted" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… EKS cluster destroyed" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… VPC and networking destroyed" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Load balancers removed" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… All data deleted" >> $GITHUB_STEP_SUMMARY

  # Job 9: Cleanup ECR (optional)
  cleanup-ecr:
    name: Cleanup ECR Images
    runs-on: ubuntu-latest
    needs: destroy-infra
    if: github.event.inputs.action == 'destroy'
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Delete ECR repository
        run: |
          aws ecr delete-repository \
            --repository-name fictions-api-development \
            --region ${{ env.AWS_REGION }} \
            --force || echo "ECR repository already deleted or doesn't exist"

      - name: Final cleanup summary
        run: |
          echo "### âœ… Complete Cleanup Finished" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All resources have been removed." >> $GITHUB_STEP_SUMMARY
          echo "No AWS charges will incur." >> $GITHUB_STEP_SUMMARY

